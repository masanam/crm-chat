{"version":3,"file":"/assets/vendor/libs/autosize/autosize.js","mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;;;;;;;;;ACVA;AACA,CAAC,KAA4D;AAC7D,CAAC,CACsD;AACvD,CAAC;AACD;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP;AACA;AACA,OAAO;AACP;AACA;;AAEA,4BAA4B;AAC5B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,OAAO;AACP;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,QAAQ;AACR;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ;AACR;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA;AACA,0DAA0D;;AAE1D;AACA;AACA,MAAM;AACN;AACA,IAAI;AACJ;AACA;AACA;AACA;AACA;AACA;AACA,IAAI;;AAEJ;AACA;AACA;AACA,qDAAqD;;AAErD;AACA;AACA;AACA;AACA;AACA,IAAI;AACJ;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,sBAAsB;;AAEtB;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,QAAQ;AACR;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA,CAAC;;;;;;;UCtOD;UACA;;UAEA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;UACA;;UAEA;UACA;;UAEA;UACA;UACA;;;;;WCtBA;WACA;WACA;WACA,eAAe,4BAA4B;WAC3C,eAAe;WACf,iCAAiC,WAAW;WAC5C;WACA;;;;;WCPA;WACA;WACA;WACA;WACA,yCAAyC,wCAAwC;WACjF;WACA;WACA;;;;;WCPA,8CAA8C;;;;;WCA9C;WACA;WACA;WACA,uDAAuD,iBAAiB;WACxE;WACA,gDAAgD,aAAa;WAC7D;;;;;;;;;;;;;;;;;ACNmD","sources":["webpack://Vuexy/webpack/universalModuleDefinition","webpack://Vuexy/./node_modules/autosize/dist/autosize.js","webpack://Vuexy/webpack/bootstrap","webpack://Vuexy/webpack/runtime/compat get default export","webpack://Vuexy/webpack/runtime/define property getters","webpack://Vuexy/webpack/runtime/hasOwnProperty shorthand","webpack://Vuexy/webpack/runtime/make namespace object","webpack://Vuexy/./resources/assets/vendor/libs/autosize/autosize.js"],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse {\n\t\tvar a = factory();\n\t\tfor(var i in a) (typeof exports === 'object' ? exports : root)[i] = a[i];\n\t}\n})(self, function() {\nreturn ","(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\n\ttypeof define === 'function' && define.amd ? define(factory) :\n\t(global = global || self, global.autosize = factory());\n}(this, (function () {\n\tvar assignedElements = new Map();\n\n\tfunction assign(ta) {\n\t  if (!ta || !ta.nodeName || ta.nodeName !== 'TEXTAREA' || assignedElements.has(ta)) return;\n\t  var previousHeight = null;\n\n\t  function cacheScrollTops(el) {\n\t    var arr = [];\n\n\t    while (el && el.parentNode && el.parentNode instanceof Element) {\n\t      if (el.parentNode.scrollTop) {\n\t        arr.push([el.parentNode, el.parentNode.scrollTop]);\n\t      }\n\n\t      el = el.parentNode;\n\t    }\n\n\t    return function () {\n\t      return arr.forEach(function (_ref) {\n\t        var node = _ref[0],\n\t            scrollTop = _ref[1];\n\t        node.style.scrollBehavior = 'auto';\n\t        node.scrollTop = scrollTop;\n\t        node.style.scrollBehavior = null;\n\t      });\n\t    };\n\t  }\n\n\t  var computed = window.getComputedStyle(ta);\n\n\t  function setHeight(_ref2) {\n\t    var _ref2$restoreTextAlig = _ref2.restoreTextAlign,\n\t        restoreTextAlign = _ref2$restoreTextAlig === void 0 ? null : _ref2$restoreTextAlig,\n\t        _ref2$testForHeightRe = _ref2.testForHeightReduction,\n\t        testForHeightReduction = _ref2$testForHeightRe === void 0 ? true : _ref2$testForHeightRe;\n\t    var initialOverflowY = computed.overflowY;\n\n\t    if (ta.scrollHeight === 0) {\n\t      // If the scrollHeight is 0, then the element probably has display:none or is detached from the DOM.\n\t      return;\n\t    } // disallow vertical resizing\n\n\n\t    if (computed.resize === 'vertical') {\n\t      ta.style.resize = 'none';\n\t    } else if (computed.resize === 'both') {\n\t      ta.style.resize = 'horizontal';\n\t    }\n\n\t    var restoreScrollTops; // remove inline height style to accurately measure situations where the textarea should shrink\n\t    // however, skip this step if the new value appends to the previous value, as textarea height should only have grown\n\n\t    if (testForHeightReduction) {\n\t      // ensure the scrollTop values of parent elements are not modified as a consequence of shrinking the textarea height\n\t      restoreScrollTops = cacheScrollTops(ta);\n\t      ta.style.height = '';\n\t    }\n\n\t    var newHeight;\n\n\t    if (computed.boxSizing === 'content-box') {\n\t      newHeight = ta.scrollHeight - (parseFloat(computed.paddingTop) + parseFloat(computed.paddingBottom));\n\t    } else {\n\t      newHeight = ta.scrollHeight + parseFloat(computed.borderTopWidth) + parseFloat(computed.borderBottomWidth);\n\t    }\n\n\t    if (computed.maxHeight !== 'none' && newHeight > parseFloat(computed.maxHeight)) {\n\t      if (computed.overflowY === 'hidden') {\n\t        ta.style.overflow = 'scroll';\n\t      }\n\n\t      newHeight = parseFloat(computed.maxHeight);\n\t    } else if (computed.overflowY !== 'hidden') {\n\t      ta.style.overflow = 'hidden';\n\t    }\n\n\t    ta.style.height = newHeight + 'px';\n\n\t    if (restoreTextAlign) {\n\t      ta.style.textAlign = restoreTextAlign;\n\t    }\n\n\t    if (restoreScrollTops) {\n\t      restoreScrollTops();\n\t    }\n\n\t    if (previousHeight !== newHeight) {\n\t      ta.dispatchEvent(new Event('autosize:resized', {\n\t        bubbles: true\n\t      }));\n\t      previousHeight = newHeight;\n\t    }\n\n\t    if (initialOverflowY !== computed.overflow && !restoreTextAlign) {\n\t      var textAlign = computed.textAlign;\n\n\t      if (computed.overflow === 'hidden') {\n\t        // Webkit fails to reflow text after overflow is hidden,\n\t        // even if hiding overflow would allow text to fit more compactly.\n\t        // The following is intended to force the necessary text reflow.\n\t        ta.style.textAlign = textAlign === 'start' ? 'end' : 'start';\n\t      }\n\n\t      setHeight({\n\t        restoreTextAlign: textAlign,\n\t        testForHeightReduction: true\n\t      });\n\t    }\n\t  }\n\n\t  function fullSetHeight() {\n\t    setHeight({\n\t      testForHeightReduction: true,\n\t      restoreTextAlign: null\n\t    });\n\t  }\n\n\t  var handleInput = function () {\n\t    var previousValue = ta.value;\n\t    return function () {\n\t      setHeight({\n\t        // if previousValue is '', check for height shrinkage because the placeholder may be taking up space instead\n\t        // if new value is merely appending to previous value, skip checking for height deduction\n\t        testForHeightReduction: previousValue === '' || !ta.value.startsWith(previousValue),\n\t        restoreTextAlign: null\n\t      });\n\t      previousValue = ta.value;\n\t    };\n\t  }();\n\n\t  var destroy = function (style) {\n\t    ta.removeEventListener('autosize:destroy', destroy);\n\t    ta.removeEventListener('autosize:update', fullSetHeight);\n\t    ta.removeEventListener('input', handleInput);\n\t    window.removeEventListener('resize', fullSetHeight); // future todo: consider replacing with ResizeObserver\n\n\t    Object.keys(style).forEach(function (key) {\n\t      return ta.style[key] = style[key];\n\t    });\n\t    assignedElements[\"delete\"](ta);\n\t  }.bind(ta, {\n\t    height: ta.style.height,\n\t    resize: ta.style.resize,\n\t    textAlign: ta.style.textAlign,\n\t    overflowY: ta.style.overflowY,\n\t    overflowX: ta.style.overflowX,\n\t    wordWrap: ta.style.wordWrap\n\t  });\n\n\t  ta.addEventListener('autosize:destroy', destroy);\n\t  ta.addEventListener('autosize:update', fullSetHeight);\n\t  ta.addEventListener('input', handleInput);\n\t  window.addEventListener('resize', fullSetHeight); // future todo: consider replacing with ResizeObserver\n\n\t  ta.style.overflowX = 'hidden';\n\t  ta.style.wordWrap = 'break-word';\n\t  assignedElements.set(ta, {\n\t    destroy: destroy,\n\t    update: fullSetHeight\n\t  });\n\t  fullSetHeight();\n\t}\n\n\tfunction destroy(ta) {\n\t  var methods = assignedElements.get(ta);\n\n\t  if (methods) {\n\t    methods.destroy();\n\t  }\n\t}\n\n\tfunction update(ta) {\n\t  var methods = assignedElements.get(ta);\n\n\t  if (methods) {\n\t    methods.update();\n\t  }\n\t}\n\n\tvar autosize = null; // Do nothing in Node.js environment\n\n\tif (typeof window === 'undefined') {\n\t  autosize = function autosize(el) {\n\t    return el;\n\t  };\n\n\t  autosize.destroy = function (el) {\n\t    return el;\n\t  };\n\n\t  autosize.update = function (el) {\n\t    return el;\n\t  };\n\t} else {\n\t  autosize = function autosize(el, options) {\n\t    if (el) {\n\t      Array.prototype.forEach.call(el.length ? el : [el], function (x) {\n\t        return assign(x);\n\t      });\n\t    }\n\n\t    return el;\n\t  };\n\n\t  autosize.destroy = function (el) {\n\t    if (el) {\n\t      Array.prototype.forEach.call(el.length ? el : [el], destroy);\n\t    }\n\n\t    return el;\n\t  };\n\n\t  autosize.update = function (el) {\n\t    if (el) {\n\t      Array.prototype.forEach.call(el.length ? el : [el], update);\n\t    }\n\n\t    return el;\n\t  };\n\t}\n\n\tvar autosize$1 = autosize;\n\n\treturn autosize$1;\n\n})));\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// getDefaultExport function for compatibility with non-harmony modules\n__webpack_require__.n = function(module) {\n\tvar getter = module && module.__esModule ?\n\t\tfunction() { return module['default']; } :\n\t\tfunction() { return module; };\n\t__webpack_require__.d(getter, { a: getter });\n\treturn getter;\n};","// define getter functions for harmony exports\n__webpack_require__.d = function(exports, definition) {\n\tfor(var key in definition) {\n\t\tif(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {\n\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n\t\t}\n\t}\n};","__webpack_require__.o = function(obj, prop) { return Object.prototype.hasOwnProperty.call(obj, prop); }","// define __esModule on exports\n__webpack_require__.r = function(exports) {\n\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n\t}\n\tObject.defineProperty(exports, '__esModule', { value: true });\n};","import * as autosize from 'autosize/dist/autosize';\n\nexport { autosize };\n"],"names":["autosize"],"sourceRoot":""}